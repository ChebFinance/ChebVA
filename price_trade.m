function mPrice = price_trade(stcTrade, stcUnderlying, stcSimParams)
% Description: Routine that computes a price matrix given risk factor
% matrices (typically mSpot, mVol) and a set of trade parameters.
%
% Inputs:   stcTrade, structure with trade information
%           stcUnderlying, structure that contains the risk factor matrices
%                   (mSpot, mVol) and other relevant underlying data (e.g. 
%                   dividend yield).
%           stcSimParams, structure that contains simulation relevant data 
%                   not in trades or underlyings (e.g. tvec).
%
% Output:   mPrice, matrix of prices for a scenario and time point in the
%                   MC simulation.
%
% Notes: Currently (08/06/12) this function supports the following input
%        details:
%        stcTrade.strInstument = forward
%                                bsoptioncall
%                                bsoptionput
%                                varianceswap
%        stcTrade.Notional = is always a cash notional, including for
%                           variance swaps.


if ~strcmp (stcTrade.strUnderlying,stcUnderlying.strUnderlying)
    error('Underlying names in Trade and Underlying structures are different');
end


if strcmp(stcTrade.strInstrument,'bsoption')
    error('Instument name must be BSOPTIONCALL or BSOPTIONPUT.');
end

if      strcmp(stcTrade.strInstrument, 'bsoptioncall')
            strInstrument = 'bsoption'; optiontype = 'call'; 
elseif  strcmp(stcTrade.strInstrument, 'bsoptionput') 
            strInstrument = 'bsoption'; optiontype = 'put'; 
else
            strInstrument = stcTrade.strInstrument;
end



T = stcTrade.T;
K = stcTrade.K;
Notional = stcTrade.Notional;
mSpot = stcUnderlying.mSpot;
mVol = stcUnderlying.mVol;
r = stcUnderlying.rate_0;
div_yield = stcUnderlying.div_yield;
tvec = stcSimParams.tvec;
dtvec = diff(tvec);

if size(mSpot,2) ~= length(tvec)
    error('Number of columns of Spot matrix must be equal length of t');
end

if size(mSpot)~=size(mVol)
    error('Wrong sizes of Spot/Vol matrices');
end


if size(mVol,2) ~= length(tvec)
    error('Number of columns of Vol matrix must be equal length of t');
end      



scens = size(mSpot,1);
t_indx = repmat(tvec<=T,scens,1);
mMaturityFlag = tvec(ones(scens,1),:); % matrix of ones/zeros indicating before/after maturity
mDt = repmat(dtvec,scens,1); % t differences stacked in a matrix



switch strInstrument

    case 'forward'
        mPrice = mSpot .* exp(-(T-mMaturityFlag)*r) ;
        mPrice = Notional * ( mPrice - K ).* t_indx;
        
    case 'bsoption'        
        [call,put] = blsprice(mSpot,K,r,(T-mMaturityFlag).*t_indx,mVol,div_yield);
        
        if strcmp(optiontype,'call')
            mPrice = Notional*call.*t_indx;
        elseif strcmp(optiontype,'put')
            mPrice = Notional*put.*t_indx;
        end
        
    case 'varianceswap'
        % We assume that pricing starts at trade inception time, i.e., MTM
        % = 0. We also assume a flat implied volatility surface.
        
        mVariance_average = 0.5*(mVol(:,2:end).^2 + mVol(:,1:end-1).^2);
        
        anualized_realized_variance = cumsum(mDt.*...
            mVariance_average,2)./mMaturityFlag(:,2:end);
                
        anualized_realized_variance = [zeros(scens,1)...
            anualized_realized_variance].*t_indx;
        
        anualized_future_variance = mVol.^2;
        mPrice = Notional * ( (mMaturityFlag/T) .* anualized_realized_variance + ...
            (T-mMaturityFlag)/T .* anualized_future_variance - K^2) .* t_ind
    case 'IRswap'
        % Quickly generated by Ignacio to have an IR Swap pricer
        % He did not understand why mMaturityFlag is not ones/zeros, as
        % estated above...
        rSpot0 = mSpot(1,1);
        mTimeToMaturity = (T-mMaturityFlag) .* t_indx;
        mDV01 = mTimeToMaturity - 0.5 .* mSpot .* mTimeToMaturity.^2;
        mPrice = (mSpot-rSpot0) .* mDV01 ;
        
       
        
        
end